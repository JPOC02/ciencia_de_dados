# pages/5_Visualiza√ß√£o_3D_Interativa.py
import streamlit as st
import pandas as pd
import plotly.express as px
from sklearn.preprocessing import MinMaxScaler
import kagglehub
import os
import numpy as np

# Fun√ß√£o de carregamento de dados (com cache)
@st.cache_data
def load_data():
    path = kagglehub.dataset_download("whenamancodes/predict-diabities")
    csv_path = os.path.join(path, 'diabetes.csv')
    df = pd.read_csv(csv_path)
    return df

# --- Configura√ß√£o da P√°gina ---
st.set_page_config(page_title="Visualiza√ß√£o 3D", page_icon="üßä", layout="wide")

# Carrega os dados
df = load_data()
if df is None:
    st.stop()

# Tratando os dados faltantes

# Lista de colunas onde os zeros seram substituidos pela mediana
cols_to_replace = ["Glucose", "BloodPressure", "SkinThickness", "Insulin", "BMI"]
# Dictionario para guardar as altera√ß√µes feitas
replacements_log = {}

# Loop que far√° a altera√ß√£o em cada coluna
for col in cols_to_replace:
    # Contador do n√∫mero de zeros na coluna
    zero_count = (df[col] == 0).sum()
    
    # S√≥ avan√ßa se houverem zeros para substituir
    if zero_count > 0:
        # Substitui inicialmente os 0s por NaN para realizar o c√°lculo correto da mediana
        # A fun√ß√£o de mediana ignora valores iguais a NaN
        df[col] = df[col].replace(0, np.nan)
        
        # Calculando a mediana
        median_val = df[col].median()
        
        # Substituindo os valores faltantes pela mediana
        df[col] = df[col].fillna(median_val)
        
        # Salvando o n√∫mero de altera√ß√µes e a mediana calculada
        replacements_log[col] = {
            'Zeros Substitu√≠dos': zero_count,
            'Valor da Mediana Usado': median_val
        }

# --- Conte√∫do da P√°gina ---
st.header("Visualiza√ß√£o 3D: IMC, Insulina e Idade")
st.write("Este gr√°fico 3D interativo permite explorar a rela√ß√£o entre IMC, Insulina e Idade, colorindo os pontos pelo resultado de diabetes.")

# Prepara√ß√£o dos dados para o gr√°fico 3D
df_3d = df[['BMI', 'Insulin', 'Age', 'Outcome']].copy()

# ---- MUDAN√áA 1: Tratar 'Outcome' como uma categoria expl√≠cita ----
# Isso garante que o Plotly a interprete corretamente para a legenda e as cores.
df_3d['Outcome'] = df_3d['Outcome'].astype('category')
    
# Aplicar transforma√ß√µes para melhor visualiza√ß√£o
df_3d['Insulin'] = df_3d['Insulin'] * 5 # Amplifica a insulina para melhor escala visual
    
# Normaliza√ß√£o dos dados para o plot
scaler = MinMaxScaler()
df_3d[['BMI', 'Insulin', 'Age']] = scaler.fit_transform(df_3d[['BMI', 'Insulin', 'Age']])
    
# Cria√ß√£o do gr√°fico com Plotly Express
fig_3d = px.scatter_3d(
    df_3d, 
    x='BMI', y='Insulin', z='Age',
    color='Outcome',
    title='Rela√ß√£o entre IMC, Insulina (x5, Normalizada) e Idade por Resultado',
    labels={'Outcome': 'Resultado'}, # Mant√©m o r√≥tulo da legenda claro

    # ---- MUDAN√áA 2: Usar 'color_discrete_map' para cores categ√≥ricas ----
    # Em vez de uma escala cont√≠nua, mapeamos cada valor para uma cor espec√≠fica.
    color_discrete_map={
        0: 'blue',  # Cor para a categoria 0 (N√£o Diab√©tico)
        1: 'orange' # Cor para a categoria 1 (Diab√©tico)
    }
)
    
# Melhorias no layout
fig_3d.update_layout(
    scene = dict(
        xaxis_title='IMC (Normalizado)',
        yaxis_title='Insulina (x5, Normalizada)',
        zaxis_title='Idade (Normalizada)'),
    margin=dict(l=0, r=0, b=0, t=40)
)
    
st.plotly_chart(fig_3d, use_container_width=True)
st.info("Use o mouse para rotacionar, dar zoom e explorar os dados neste gr√°fico interativo.")